## JAKE A TUTMAHER
## JOHNS HOPKINS UNIVERSITY
## MCQUEEN LABORATORY
## THE INSTITUTE FOR QUANTUM MATTER
## DEPARTMENT OF PHYSICS, DEPARTMENT OF CHEMISTRY, DEPARTMENT OF MATERIALS SCIENCE AND ENGINEERING
##
## CONTACT: jtutmah1@jhu.edu
####################################################################################################

""" Set of functions design to read VASP output files and generate numpy arrays. More
 detailed descriptions included below.
 
 ---
"""

####################################################################################################

#===========================    IMPORT SPECIFIC PACKAGES   =================================
import numpy as np
import os
import csv
from numpy import linalg as LA
import IQM.VASPread as VASPread
import IQM.PHONOPYread as PHONOPYread
import multiprocessing

#===========================    MAIN METHODS FOR INPUTS   =================================

def get_current_directory():
    """ get current directory wherever script is being CALLED from. """  
    curr_directory = os.popen("pwd").readlines()[0]
    length=len(curr_directory)
    curr_directory = curr_directory[:length-1]+"/" 
    return curr_directory

def get_immediate_subdirectories(dir1):
    """ Returns a list of all subdirectorys where script is CALLED from. """ 
    return [name for name in os.listdir(dir1)
            if os.path.isdir(os.path.join(dir1, name))]

def get_converged_folders(csvfile):    
    """ This function essentially searches the summary.csv file generated by check.py (in PYTHON folder)
        and returns an array of all converged compounds. In order to be in the array, a compound must
        have successfully completed its Relaxation, Static, and DFPT runs.
    """
    #DEFINE STATUS ARRAYS
    name=[]
    relax_stat=[]
    stat_stat=[]
    dfpt_stat=[]
    
    #READ SUMMARY FILE
    txtfile = open(csvfile)
    reader = csv.DictReader(txtfile)
    for row in reader:
        name = np.append(name,row["COMPOUND"])
        relax_stat = np.append(relax_stat,row["RELAX"])
        stat_stat = np.append(stat_stat,row["STATIC"])
        dfpt_stat = np.append(dfpt_stat,row["DFPT"])
    
    #GET CONVERGED FOLDERS  
    folder = []
    for i in range(len(name)):
        if "Y" in relax_stat[i] and "Y" in stat_stat[i] and "Y" in dfpt_stat[i]:
            folder = np.append(folder,name[i])
        else:
            continue    
        
    return folder
    
def qpoints(dir1):
    """ This function generates a NECESSARY QPOINTS file for PHONOPY. When doing mesh sampling with PHONOPY
        you need to tell it ALL kpoints to sample the material at. For consistency, we use the exact kpoints
        as the electronic (static) run. Thus, the EIGENVAL file from the STATIC folder (which lists all is 
        kpoints used) is read in and the kpoints are copied over to a QPOINTS file in the DFPT directory.
        Note the primary input @dir1 - is the MAIN compound directory. I.E. ~/work/myname/Test/COMPOUND/.
        
        This function is implemented in the PYTHON/inputs.py script.
    """
    #FIND EIGENVAL FILE - RETURN TO MAIN SCRIPT IF MISSING
    if os.stat(dir1+'STATIC/EIGENVAL').st_size==0:
        print 'Skipping '+dir1
        return
    #IF EIGENVAL FILE FOUND
    else:
        #INITIALIZE FILE
        eigenfile = VASPread.eigenval(dir1+'STATIC/')
        
        #GET KPOINT INFORMATION
        kpoints = eigenfile.kpoints()
        length = len(kpoints[0,:])
        
        #WRITE KPOINTS INFORMATION TO QPOINTS FILE IN DFPT DIR
        qfile=open(dir1+'DFPT/'+'QPOINTS','w')
        qfile.write(str(length)+'\n')	
        for i in range(length):
            kpoint = kpoints[:,i]
            qfile.write(str(kpoint[0])+' '+str(kpoint[1])+' '+str(kpoint[2])+' \n')
        qfile.close()	
        return

def reformat_energy(energymat):
    """This function reformats an energy numpy array AFTER is has been read in with the VASPread class. VASPread
       organizes spin-polarized and non spin-polarized data differently, since the EIGENVAL files are 
       structured differently for these runs. A spin polarized run will have dimensions 2 x nkpts x nbands,
       whereas a non spin-polarized run will have dimensions 1 x nkpts x nbands. This function returns a 
       numpy array with dimensions 2*nkpts x nbands or nkpts x nbands depending on the situation.
       
       This function is implemented in several scripts, including the postprocess.py script.
    """
    #IF SPIN POLARIZED - FIRST DIMENSION OF ARRAY WILL BE 2
    if energymat.shape[0]==2:
        energymat_new = np.zeros((energymat.shape[1],2*energymat.shape[2]))
        count=0
        #SPIN POLARIZED DATA HAS TO BE ORGANIZED EVERY-OTHER-ONE - SINCE IT LISTS SPIN UP FIRST
        #FOLLOWED BY SPIN DOWN. THE SPIN UPS AND SPIN DOWNS ARE DEGENERATE AT EACH LEVEL.
        for i in range(energymat.shape[2]):
            energymat_new[:,count] = energymat[0,:,i]
            count+=1
            energymat_new[:,count] = energymat[1,:,i]
            count+=1
    
    #ELSE - FIRST DIMENSION OF ARRAY WILL BE 1
    else:
        energymat_new = np.zeros((energymat.shape[1],energymat.shape[2]))
        energymat_new[:,:] = energymat[0,:,:]
    return energymat_new
                    
def get_reclats(dirmain,dirsave,compound):
    """ Return and save (@dirsave) reciprocal lattice vectors as a numpy array by simply reading them from the 
        OUTCAR located in @dirmain & @compound folder using VASPread. See VASPread documentation for more detail.
    """
    outfile = VASPread.outcar(dirmain+compound+"/STATIC/")
    reclat = outfile.reclatvec()
    np.save(dirsave+compound+'/reclat',reclat)
    return

def get_natoms(dirmain,dirsave,compound):
    """ Return and save the number of atoms as a float using the VASPread methods. See VASPread
        documentation for more detail. The @dirmain and @compound variables define the comound
        directory to read the info from. I.E. ~/work/myname/Test/ would be @dirmain, and @compound
        would be MgB2.
    """
    outfile = VASPread.outcar(dirmain+compound+"/STATIC/")
    natoms = outfile.nions()
    np.save(dirsave+compound+'/natoms',natoms)
    return      

def meshgrid(kpoints,energies):
    """MESHGRID is an important function that is utilized by several scripts. Kpoint and Energy data is 
       output by VASP in a somewhat strange (and linear) order. I.E. kx: 0.000 -> 0.111 -> 0.222 -> 0.333
       -> 0.444 -> -0.444 -> -0.333 -> -0.222 -> -0.111 for a 9x9x9 kpoint grid. We want these values 
       reordered into a 9x9x9 grid (or whatever arbitrary kpt sampling) for postprocessing. This function
       takes the inputs @kpoints and @energies - which have dimensions 3 x nkpts and nkpts x nbands 
       respectively - and restructure them into a kpt x kpt x kpt x 3 array or kpt x kpt x kpt x nbands
       array.
       
       This function is implemented in several scripts, including the PYTHON/inputs.py, PYTHON/surface.py,
       and PYTHON/bxsf.py.
    """
    #GET DIMENSIONS OF SQUARE KPT GRID FROM RAW VASP DATA - @kpoints
    nkpts = kpoints.shape[1]
    
    #SQUARE DIMENSIONS WILL BE CUBED ROOT OF THIS
    kpts = int(round(nkpts**(1./3)))     
    ksamp = [kpts,kpts,kpts]
    
    #GET NUMBER OF BANDS
    nbands = energies.shape[1]
    
    #INITALIZE KPOINT AND ENERGY ARRAYS
    kmat = np.zeros((kpts,kpts,kpts,3))
    energymat = np.zeros((kpts,kpts,kpts,nbands))
    center = kpts/2
    
    #REORGRANIZE INTO GAMMA-CENTERED SQUARE MATRICES
    for j in range(ksamp[0]):
        for k in range(ksamp[1]):
            for l in range(ksamp[2]):
                if l<center:
                    kx = l+center+1
                else:
                    kx = l-center
                if j <= center:
                    if k <= center:
                        kmat[l,k+center,j+center,:] = kpoints[:,kx+k*ksamp[1]+j*ksamp[0]**2]
                        energymat[l,k+center,j+center,:] = energies[kx+k*ksamp[1]+j*ksamp[0]**2,:]
                    else:
                        kmat[l,k-center-1,j+center,:] = kpoints[:,kx+k*ksamp[1]+j*ksamp[0]**2]
                        energymat[l,k-center-1,j+center,:] = energies[kx+k*ksamp[1]+j*ksamp[0]**2,:]
                else:
                    if k <= center:
                        kmat[l,k+center,j-center-1,:] = kpoints[:,kx+k*ksamp[1]+j*ksamp[0]**2]
                        energymat[l,k+center,j-center-1,:] = energies[kx+k*ksamp[1]+j*ksamp[0]**2,:]
                    else:
                        kmat[l,k-center-1,j-center-1,:] = kpoints[:,kx+k*ksamp[1]+j*ksamp[0]**2]
                        energymat[l,k-center-1,j-center-1,:] = energies[kx+k*ksamp[1]+j*ksamp[0]**2,:]
                        
    return kmat,energymat
